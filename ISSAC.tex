\documentclass[12pt]{article}
\usepackage{sigsam, amsmath}
\newtheorem{theorem}{Theorem}

% additional commands
\newcommand{\F}{\mathbb{F}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\Ell}{\mathrm{Ell}}
\newcommand{\Cl}{\mathcal{C}}
\newcommand{\ms}{\mathrm{\ ms}}
\newcommand{\s}{\mathrm{\ s}}

% leave as is
\issue{TBA}
\articlehead{TBA}
\titlehead{Isogeny-based cryptography in Julia/Nemo: a case study}
\authorhead{Jean Kieffer, Luca De Feo}
\setcounter{page}{1}

\begin{document}

\title{Isogeny-based cryptography in Julia/Nemo: a case study}

\author{Jean Kieffer \\
\'Ecole normale sup\'erieure de Paris \& INRIA, Universit\'e Paris-Saclay \\
\url{jean.kieffer@ens.fr}
\and
Luca De Feo \\
Universit\'e de Versailles \& INRIA, Universit\'e Paris-Saclay \\
\url{luca.defeo@polytechnique.edu}}

\maketitle

\begin{abstract}
We study a key-exchange protocol based on elliptic curves. Such cryptosystems are of interest because they may resist quantum attacks, but it remains a challenge to design efficient ones. We briefly present the calculations involved, highlighting critical steps and efficient algorithms to achieve them, as well as timing results for our implementations in Sage and Julia/Nemo.
\end{abstract}

\section{Introduction}

In \cite{RS}, Rostovtsev and Stolbunov proposed using isogenies between ordinary elliptic curves over finite fields to build key-exchange and public-key encryption schemes, rediscovering Couveignes' idea \cite{Couveignes}. This scheme is based on the simply transitive action of the abelian group $\Cl(\O)$, the class group of an order in a quadratic field, on $\Ell_t(\O)$, the set of elliptic curves over a (prime) finite field $\F_p$ with Frobenius trace $t$ and complex multiplication by the order $\O$. Elements in $\Cl(\O)$ are represented as a product of ideals of prime norm, up to a certain bound. Computing this action then amounts to following a path in the so-called \emph{isogeny graph}, whose vertices are elements in $\Ell_t(\O)$ and edges are isogenies corresponding to ideals. A complete key exchange works as follows:

\vspace{2mm}
\textbf{Algorithm 1 :} Key exchange

\noindent
Input : $E_0\in \Ell_t(\O)$, a set of primes $L$, a bound $K$

\noindent
1. Alice and Bob choose random elements $n_\ell^A, n_\ell^B\in [0, K]$ for each $\ell\in L$

\noindent
2. Starting from $E_0$, for each $\ell\in L$, they walk $n_\ell^A$ (resp. $n_\ell^B$) steps labelled by $\ell$ in the isogeny graph; they obtain $E_A$ and $E_B$ respectively and exchange them.

\noindent
3. They do the same computation starting from $E_B$ (resp. $E_A$)

\noindent
Output : the final curve is the common key.
\vspace{2mm}

Note that we cannot use all primes, but only about half of them: these primes are usually called \emph{Elkies primes} in point counting. One could try to find special curves, for which more primes could are Elkies. It is a major issue since the security of the scheme grows exponentially with the length of $L$ and only polynomially with $K$, and we return to this question later on.

\section{A first solution}

The crucial question in the previous algorithm is how to compute isogenies of fixed prime degree from a given elliptic curve. A standard answer for this is to use modular polynomials. We choose from the beginning and for each convenient $\ell$ one root $v_\ell$ of the polynomial $X^2 - tX + p$ modulo $\ell$, called \emph{Frobenius eigenvalue} mod $\ell.$

\vspace{2mm}
\textbf{Algorithm 2 :} Step in the isogeny graph

\noindent
Input : $E\in \Ell_t(\O)$, a prime $\ell$, the modular polynomial $\Phi_\ell(X, Y)$, the Frobenius eigenvalue $v_\ell\in \F_\ell$

\noindent
1. Compute the $j$-invariant $j_E$ of $E$ and the polynomial $\Phi_\ell(X, j_E)$

\noindent
2. Find its two roots $j_1, j_2\in \F_p$, and find image curves $E_1, E_2$.

\noindent
3. Compute the kernel of the isogeny $E \to E_1$.

\noindent
4. Compute the action of Frobenius $x\mapsto x^p$ and the scalar multiplication $x\mapsto [v]x$ on it.

\noindent
Output : $E_1$ if the previous are equal, else $E_2$.
\vspace{2mm}

To handle Step 3, we use the Bostan--Morain--Salvy--Schost algorithm \cite{BMSS}. It involves finding a rational function satisfying a differential equation, which is solved using a Newton iteration. Finally we recover the polynomials we want using the Berlekamp--Massey algorithm. In this setting, the most expensive part of the whole computation is to find the roots of $\Phi_\ell(X, j_E)$, a polynomial of degree $\ell + 1$. For this, we use the Cantor--Zassenhaus algorithm, performing equal-degree factorisation only in degree 1.

To fix ideas, let us give an example of parameters achieving security comparable with contemporary cryptosystems, against the best known classical attacks. We set $p = 2^{500} + 55$, $K = 2$, $E\ :\ y^2 = x^3 + 5x^2 + x$, and a set $L$ of 115 convenient primes below $1400$ (out of 222), for which we use precomputed modular polynomials. We obtain a total computing time of approximately 7 minutes for a single cryptographic operation (half a key-exchange or one encryption), with about 20 seconds spent on each of the largest primes.

\section{Faster $\ell$-isogenies with torsion points}

If $E$ admits primitive rational $\ell$-torsion points, we may replace Algorithm 2 with a faster method:

\vspace{2mm}
\textbf{Algorithm 3 :} Step using torsion points

\noindent
Input : $E\in \Ell_t(\O)$, an Elkies prime $\ell$ such that $E$ has rational $\ell$-torsion points

\noindent
1. Choose a random rational point $P$ on $E$

\noindent
2. Compute $Q = [C/\ell]P$, where $C$ is the common cardinality of all elliptic curves involved

\noindent
3. If $Q = 0$, restart; else $Q$ is a primitive $\ell$-torsion point on $E$

\noindent
4. Compute the subgroup $S$ generated by $Q$ using repeated additions on $E$

\noindent
Output : The curve $E/S$ obtained using V\'elu's formulae. %(e.g. \cite{Kohel}, 2.4).
\vspace{2mm}

The costly part in Algorithm 3 is Step 2, assuming $\ell$ is not too large. We compute scalar multiplications on $E$ using repeated additions and doublings. In order to optimize the number of $\F_p$-operations, we implemented it using Montgomery curves and arithmetic on the $x$-line \cite{Montgomery}, achieving dramatic performance gains compared to the previous algorithms.

However, to exploit this speed-up, we have to find elliptic curves over $\F_p$ whose cardinality is divisible by lots of small prime numbers. What can be achieved in a reasonable amount of time, and what speed-up we can obtain, seem interesting questions. Note that this divisibility  condition may be relaxed a little, allowing torsion points defined over field extensions of small degree.

\section{Results}

Finally we compare our implementations in Sage \cite{Sage} and Nemo \cite{Nemo}. Using Algorithm 2, the costly computation is that of $X^p$ modulo a polynomial of degree $d$. We used Sage and Nemo built-ins for this common computation, giving the following results.
\[\begin{array}{c|c|c|c|c|c|c|c|c|c}
d & 2 & 5 & 10 & 20 & 50 & 100 & 200 & 500 & 1000\\
\hline
\text{Sage} & 40 \ms & 40 \ms & 55\ms & 70 \ms & 155\ms & 510\ms & 1.0 \s & 2.2 \s & 5.3 \s\\
\hline
\text{Nemo} & 3.5 \ms &  14 \ms & 38 \ms & 90 \ms & 220 \ms & 460 \ms & 980 \ms & 2.5 \s & 5.5 \s
\end{array}\]
Sage also spends additional time in precomputations (as much as 7 minutes in the last example). While this may prove efficient when a lot of calculations are to be done in the same ring, this is not the case in our setting. Sage relies on NTL \cite{NTL}, PARI \cite{Pari} and GMP \cite{GMP} for these computations.

With Algorithm 3, one computes scalar multiples $[m]P$ with $m\simeq p^d$ and $P\in E(\F_{p^d})$. As elliptic curves are not yet supported in Nemo, we implemented our own Montgomery arithmetic. In Sage we use the built-in scalar multiplication. Our timings are as follows:
$$\begin{array}{c|c|c|c|c|c|c|c|c|c}
d & 1 & 3 & 4 & 5 & 7 & 8 & 9 & 11 & 50\\
\hline
\text{Sage} & 38 \ms & 190 \ms & 270 \ms & 320 \ms & 470 \ms & 530 \ms & 610 \ms & 780 \ms & 5.7 \s\\
\hline
\text{Nemo} & 7 \ms & 23 \ms & 30 \ms & 38 \ms & 55 \ms & 65 \ms & 75 \ms & 130 \ms & 620\ms
\end{array}$$
Further experiments show that Julia's compilation and fast arithmetic on Montgomery curves are equally reponsible for these gains.

\begin{thebibliography}{99}

\bibitem{BMSS}
A. Bostan, F. Morain, B. Salvy, \'E. Schost.
\newblock Fast algorithms for computing isogenies between elliptic curves.
\newblock {\em Math. Computation}, 77:263:1755--1778, 2008.

\bibitem{Couveignes}
J.-M. Couveignes.
\newblock Hard homogeneous spaces.
\newblock 2006.

\bibitem{Nemo}
C. Fieker, W. Hart, T. Hofmann, F. Johansson et. al.
\newblock the Nemo computer algebra package, version 0.6.0, {\tt http://nemocas.org}.

\bibitem{GMP}
T. Granlund and the GMP development team,
\newblock The GNU Multi Precision Arithmetic Library, \url{http://gmplib.org/}

\bibitem{Montgomery}
P. L. Montgomery.
\newblock Speeding the Pollard and Elliptic Curve Methods of Factorization.
\newblock {\em Math.Comput.} 47:177:243--264,1987.

\bibitem{Pari}
The PARI~Group.
\newblock PARI/GP version {\tt 2.9.0}, Univ. Bordeaux, 2016, \url{http://pari.math.u-bordeaux.fr/}.

\bibitem{RS}
A. Rostovtsev, A. Stolbunov.
\newblock Public-key cryptosystem based on isogenies.

\bibitem{Sage}
The Sage Developers.
\newblock {S}ageMath, the {S}age {M}athematics {S}oftware {S}ystem ({V}ersion
  7.5.1),
\newblock 2017, {\tt http://www.sagemath.org}.

\bibitem{NTL}
V. Shoup.
\newblock NTL : a library for doing number theory.

%\bibitem{Waterhouse}
%W. C. Waterhouse.
%\newblock Abelian varieties over finite fields.
%\newblock {\em Ann. sci. \'E.N.S.} 2:4:521--560, 1969.

%\bibitem{Attack}
%S. Galbraith.
%\newblock Constructing isogenies between elliptic curves over finite fields.
%\newblock {\em LMS J. Comput. Math.} 2:118--138, 1999.

%\bibitem{Kohel}
%D. Kohel.
%\newblock Endomorphism rings of elliptic curves over finite fields.

%\bibitem{Flint}
%W. Hart, F. Johansson, S. Pancratz.
%\newblock {FLINT}: {F}ast {L}ibrary for {N}umber {T}heory, 2013,
%\newblock Version 2.4.0, \url{http://flintlib.org}

\end{thebibliography}

\end{document}